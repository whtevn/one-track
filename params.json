{"name":"One-track","tagline":"simple router","body":"Installation\r\n------------\r\n\r\n```\r\nnpm install one-track --save\r\n```\r\n\r\nif intending to use with koa2\r\n\r\n```\r\nnpm install one-track one-track-koa koa@next koa-bodyparse@3 --save\r\n```\r\n\r\nnote that none of those are required to use this package, but they are \r\nused in the demonstrations below\r\n\r\nUsage with Koa2\r\n---------------\r\n\r\n```js\r\nimport Koa from 'koa';\r\nimport bodyParser from 'koa-bodyparser';\r\nimport RouteManager from 'one-track';\r\nimport RouteMiddleware from 'one-track-koa';\r\n\r\nimport { retrieve_user } from './your-app';\r\n\r\nconst app          = new Koa();\r\nconst Router       = new RouteManager();\r\n\r\nRouter.GET('/user/:id', retrieve_user);\r\n\r\napp.use(bodyParser());\r\napp.use(RouteMiddleware(Router))\r\n```\r\n\r\nThe above code will create the routes described, and call the functions\r\nimplied with the following argument signature \r\n\r\n```js\r\n(params, headers, body, app)\r\n```\r\n\r\nwhere `app` is the Koa app context. Router supports standard CRUD opperations\r\n\r\nfor example:\r\n\r\n```js\r\nRouter.GET('/user/:id', retrieve_user);\r\nRouter.POST('/user', create_user);\r\nRouter.PUT('/user/:id', update_user);\r\nRouter.DELETE('/user/:id', delete_user);\r\n```\r\n\r\nRouter Chaining \r\n---------------\r\n\r\nRouters can be created from other Routers without disturbing the original\r\n\r\n```js\r\nconst Router       = new RouteManager();\r\nRouter.GET('/user/:id', retrieve_user);\r\n\r\nRouter_2 = new RouteManager(Router);\r\nRouter_2.Post('/user', create_user);\r\n```\r\n\r\nIn the above example, the Router object has 1 route (`GET '/user/:id'`), and the\r\n`Router_2` object has 2 (`GET '/user/:id'` and `POST '/user'`);\r\n\r\n\r\nRouted Function Context \r\n-----------------------\r\n\r\nSometimes it is important to dictate the scope that a function is called, defining\r\n`this` for the context of the function. To do this, an array notation of `[scope, function]` \r\nis used. \r\n\r\nIf the function is a string, the context is searched for the function's name\r\n\r\n```js\r\nRouter.get('/user/:id', [user, 'find']); //=> user['find'].call(user, ...args)\r\n```\r\n\r\nOtherwise the function is called with the context given\r\n\r\n```js\r\nRouter.get('/user/:id', [user, retrieve_user]); //=> retrieve_user.call(user, ...args)\r\n```\r\n\r\nArgument Translation \r\n--------------------\r\n\r\nArgument translators can be used to map the unweildy data from the request\r\ninto something an environment-agnostic method can process\r\n\r\n```js\r\nimport Koa from 'koa';\r\nimport bodyParser from 'koa-bodyparser';\r\nimport RouteManager, { Send } from 'one-track';\r\nimport RouteMiddleware from 'one-track-koa';\r\n\r\nimport { retrieve_user } from './your-app';\r\n\r\n// translate the arguments that come from the koa app\r\n// into something that the retrieve_user method can understand\r\n\r\nconst koa_retrieve_user = Send((params, headers, body, app) => [params.id]).to(retrieve_user);\r\n\r\nRouter.GET('/user/:id', koa_retrieve_user);\r\n```\r\n\r\nThis allows you to create functions that do not care about the environment that they \r\nultimately live in. This also allows functions to live in multiple contexts, and for\r\ncontexts to change, without affecting the business logic\r\n\r\nArgument translations also respond to the array notation given above\r\n\r\n```js\r\nSend((params, headers, body, app) => [params.id]).to([User, retrieve_user]);\r\n```\r\n\r\n\r\nHello World with Koa2 \r\n=====================\r\n\r\n```js\r\nimport Koa from 'koa';\r\nimport bodyParser from 'koa-bodyparser';\r\nimport RouteManager from '../index';\r\nimport RouteMiddleware from '../one-track-koa';\r\n\r\nconst app          = new Koa();\r\nconst Router       = new RouteManager();\r\n\r\nfunction hello({place}){\r\nconsole.log(\"in hello\");\r\nreturn \"hello, \"+place\r\n}\r\n\r\nfunction goodbye(){\r\nconsole.log(\"in goodbye\");\r\nreturn \"goodbye\"\r\n}\r\n\r\nfunction say(phrase){\r\nconsole.log(\"in say\");\r\nreturn \"say \"+phrase;\r\n}\r\n\r\nRouter.GET('/hello/:place', hello);            // => hello, {place}\r\nRouter.GET('/say/hello/:place', hello, say);   // => say hello, {place}      \r\nRouter.GET('/say/goodbye', goodbye, say);      // => say goodbye\r\nRouter.GET('/goodbye', goodbye);               // => goodbye\r\n\r\napp.use(bodyParser());\r\napp.use(RouteMiddleware(Router))\r\n\r\napp.listen(3000);\r\nconsole.log(\"app is listening\");\r\n```\r\n\r\nAuthentication Middleware Example \r\n=================================\r\n\r\nThe two code samples below are functionally equivalent. The first simply does the job,\r\nthe second takes advantage of argument translators to abstract the request from the \r\nprocess of authentication\r\n\r\n### Basic signature-checking authentication middleware  \r\n\r\n```js\r\nfunction simple_auth(params, headers, ...args){\r\n  if(sign(headers.user_id, SECRET) !== headers.authorization) throw {code:401, message:\"Unauthorized\"}\r\n  return [params, headers, ...args]\r\n}\r\n```\r\n\r\n### Middleware example using argument translations\r\n\r\n```js\r\n// this is a simple signature method that should not be used in production \r\nconst sign  = (user, secret=SECRET) => user+secret;\r\n\r\n// step 1: translate args to a method your validation function will understand.\r\n//         in this case we are returning the user id and auth sent in the header\r\n//         followed by the rest of the arguments in the appropriate order\r\nfunction authentication_arguments(params, headers, ...args){\r\n  return [headers.user_id, headers.authorization, params, headers, ...args]\r\n}\r\n\r\n// step 2: validate the user and return the remaining arguments\r\nfunction validate_authentication(user, token, ...args){\r\n   if(sign(user, SECRET) !== token) throw {code:401, message:\"Unauthorized\"}\r\n   return args\r\n}\r\n\r\n// step 3: create the authentication middleware by sending the proper authentication\r\n//         arguments to the authentication checker\r\nconst authenticate = Send(authentication_arguments).to(validate_authentication);\r\n```\r\n\r\n### example usage of above middleware\r\n\r\n```js\r\n// example request headers:\r\n//   user_id      : APPLE\r\n//   Authorization: APPLESAUCE\r\nR2.POST('/goodbye/:say', authenticate,\r\n                      Send((params)=>[params.say]).to(goodbye),\r\n                      say);       \r\n```\r\n\r\nGeneral Usage \r\n-------------\r\n\r\nOne-Track does not require a server to work. Any application which can\r\nreceive events can be routed through this software.\r\n\r\n```js\r\nimport RouteManager, { Send, GET } from 'one-track';\r\nconst Router = new RouteManager();\r\n\r\nRouter.GET('/path/:id/other/:info', another_function);\r\n```\r\n\r\nIn this case, calling\r\n\r\n```js\r\nRouter.find(GET, '/path/some_id/other/text_to_send', arg1, arg2)\r\n```\r\n\r\nis basically equivalent to calling\r\n\r\n```js\r\n(function(){\r\nreturn new Promise(resolve, reject){\r\n  resolve(another_function.call(this, ...arguments));\r\n}\r\n})()\r\n```\r\n\r\nwhere `arg_1` and `arg_2` would be passed into `another_function`, since\r\nthey are being passed in through the final arguments send in with `Router.find`.\r\nSo, the koa middleware really ends up being as simple as setting the body of \r\nthe response to the result of the request path's function, with the relevant \r\ninfo of the body, headers, and Koa context passed in as arguments\r\n\r\n### one-track-koa middleware\r\n\r\nThe default one-track-koa middleware is as follows. However, only the first \r\ntwo arguments sent to `.find()` are required. The remaining arguments indicate\r\nthe arguments that will be sent to the function indicated by `.find()`.\r\n\r\nIn other words, altering this middleware to send different information to your\r\napplication is as trivial as adding, removing, or changing arguments after the\r\nreference to `ctx.path`\r\n\r\n```js\r\nconst middleware = (Router) => async (ctx, next) => {\r\n  ctx.body = await Router\r\n                    .find(ctx.method, ctx.path, ctx.request.body, ctx.headers, ctx)\r\n                    .catch((err) => {\r\n                      console.log(err.stack||err);\r\n                      ctx.status = err.code||ctx.status;\r\n                      return err;\r\n                    });\r\n}\r\nexport default middleware\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}