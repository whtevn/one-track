{"name":"One-track","tagline":"simple router","body":"Installation\r\n------------\r\n\r\n    npm install one-track --save\r\n\r\nif intending to use with koa2\r\n\r\n    npm install one-track one-track-koa koa@next koa-bodyparse@3 --save\r\n\r\nnote that none of those are required to use this package, but they are \r\nused in the demonstrations below\r\n\r\nUsage with Koa2\r\n---------------\r\n\r\n    import Koa from 'koa';\r\n    import bodyParser from 'koa-bodyparser';\r\n    import RouteManager from 'one-track';\r\n    import RouteMiddleware from 'one-track-koa';\r\n\r\n    import { retrieve_user } from './your-app';\r\n\r\n    const app          = new Koa();\r\n    const Router       = new RouteManager();\r\n\r\n    Router.GET('/user/:id', retrieve_user);\r\n\r\n    app.use(bodyParser());\r\n    app.use(RouteMiddleware(Router))\r\n\r\nThe above code will create the routes described, and call the functions\r\nimplied with the following argument signature \r\n\r\n    (headers, params, body, app)\r\n\r\nwhere `app` is the Koa app context. Router supports standard CRUD opperations\r\n\r\nfor example:\r\n\r\n    Router.GET('/user/:id', retrieve_user);\r\n    Router.POST('/user', create_user);\r\n    Router.PUT('/user/:id', update_user);\r\n    Router.DELETE('/user/:id', delete_user);\r\n\r\nRouter Chaining \r\n---------------\r\n\r\nRouters can be created from other Routers without disturbing the original\r\n\r\n    const Router       = new RouteManager();\r\n    Router.GET('/user/:id', retrieve_user);\r\n\r\n    Router_2 = new RouteManager(Router);\r\n    Router_2.Post('/user');\r\n\r\nIn the above example, the Router object has 1 route (`GET '/user/:id'`), and the\r\n`Router_2` object has 2 (`GET '/user/:id'` and `POST '/user'`);\r\n\r\n\r\nRouted Function Context \r\n-----------------------\r\n\r\nSometimes it is important to dictate the scope that a function is called, defining\r\n`this` for the context of the function. To do this, an array notation of `[scope, function]` \r\nis used. \r\n\r\nIf the function is a string, the context is searched for the function's name\r\n\r\n    Router.get('/user/:id', [user, 'find']); //=> user['find'].call(user, ...args)\r\n\r\nOtherwise the function is called with the context given\r\n\r\n    Router.get('/user/:id', [user, retrieve_user]); //=> retrieve_user.call(user, ...args)\r\n\r\nArgument Translation \r\n--------------------\r\n\r\nArgument translators can be used to map the unweildy data from the request\r\ninto something an environment-agnostic method can process\r\n\r\n    import Koa from 'koa';\r\n    import bodyParser from 'koa-bodyparser';\r\n    import RouteManager, { Send } from 'one-track';\r\n    import RouteMiddleware from 'one-track-koa';\r\n\r\n    import { retrieve_user } from './your-app';\r\n\r\n    // translate the arguments that come from the koa app\r\n    // into something that the retrieve_user method can understand\r\n\r\n    const koa_retrieve_user = Send((headers, params, body, app) => [params.id]).to(retrieve_user);\r\n\r\n    Router.GET('/user/:id', koa_retrieve_user);\r\n\r\nThis allows you to create functions that do not care about the environment that they \r\nultimately live in. This also allows functions to live in multiple contexts, and for\r\ncontexts to change, without affecting the business logic\r\n\r\nArgument translations also respond to the array notation given above\r\n\r\n    Send((headers, params, body, app) => [params.id]).to([User, retrieve_user]);\r\n\r\nGeneral Usage \r\n-------------\r\n\r\nOne-Track does not require a server to work. Any application which can\r\nreceive events can be routed through this software.\r\n\r\n    import RouteManager, { Send, GET } from 'one-track';\r\n    const Router = new RouteManager();\r\n\r\n    Router.GET('/path/:id/other/:info', another_function);\r\n\r\nIn this case, calling\r\n\r\n    Router.find(GET, '/path/some_id/other/text_to_send')\r\n\r\nis basically equivalent to calling\r\n\r\n    (function(){\r\n      return new Promise(resolve, reject){\r\n        resolve(another_function.call(this, ...arguments));\r\n      }\r\n    })()\r\n\r\n\r\nHello World with Koa2 \r\n=====================\r\n\r\n    import Koa from 'koa';\r\n    import bodyParser from 'koa-bodyparser';\r\n    import RouteManager from '../index';\r\n    import RouteMiddleware from '../one-track-koa';\r\n\r\n    const app          = new Koa();\r\n    const Router       = new RouteManager();\r\n\r\n    function hello({place}){\r\n      console.log(\"in hello\");\r\n      return \"hello, \"+place\r\n    }\r\n\r\n    function goodbye(){\r\n      console.log(\"in goodbye\");\r\n      return \"goodbye\"\r\n    }\r\n\r\n    function say(phrase){\r\n      console.log(\"in say\");\r\n      return \"say \"+phrase;\r\n    }\r\n\r\n    Router.GET('/hello/:place', hello);            // => hello, {place}\r\n    Router.GET('/say/hello/:place', hello, say);   // => say hello, {place}      \r\n    Router.GET('/say/goodbye', goodbye, say);      // => say goodbye\r\n    Router.GET('/goodbye', goodbye);               // => goodbye\r\n\r\n    app.use(bodyParser());\r\n    app.use(RouteMiddleware(Router))\r\n\r\n    app.listen(3000);\r\n    console.log(\"app is listening\");\r\n\r\n\r\nMore Examples \r\n=============\r\n\r\n== Authentication Middleware: 2 ways\r\n\r\nThe first method uses argument translations \r\n\r\n      // this is a simple signature method that should not be used in production \r\n      const sign  = (user, secret=SECRET) => user+secret;\r\n\r\n      // step 1: translate args to a method your validation function will understand.\r\n      //         in this case we are returning the user id and auth sent in the header\r\n      //         followed by the rest of the arguments in the appropriate order\r\n      function authentication_arguments(headers, ...args){\r\n        return [headers.user_id, headers.authorization, headers, ...args]\r\n      }\r\n\r\n      // step 2: validate the user and return the remaining arguments\r\n      function validate_authentication(user, token, ...args){\r\n         if(sign(user, SECRET) !== token) throw {code:401, message:\"Unauthorized\"}\r\n         return args\r\n      }\r\n\r\n      // step 3: create the authentication middleware by sending the proper authentication\r\n      //         arguments to the authentication checker\r\n      const authenticate = Send(authentication_arguments).to(validate_authentication);\r\n\r\n\r\nThe second just does the job\r\n\r\n    /***************************************/\r\n      // NOTE: very little of the above is actually required. The following function `simple_auth`\r\n      //       and the constant `authenticate` created above are functionally equivalent.\r\n      //       the advantage of the `authenticate` constant being that the algorithm is not \r\n      //       tied to the request-related arguments as they are sent\r\n      function simple_auth(headers, ...args){\r\n        if(sign(headers.user_id, SECRET) !== headers.authorization) throw {code:401, message:\"Unauthorized\"}\r\n        return [headers, ...args]\r\n      }\r\n    /***************************************/\r\n\r\nexample usage of above middleware\r\n\r\n    // example request headers:\r\n    //   user_id      : APPLE\r\n    //   Authorization: APPLESAUCE\r\n    R2.POST('/goodbye/:say', authenticate,\r\n                            Send((headers, params)=>[params.say]).to(goodbye),\r\n                            say);       \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}