<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>One-track by whtevn</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">One-track</h1>
      <h2 class="project-tagline">simple router</h2>
      <a href="https://github.com/whtevn/one-track" class="btn">View on GitHub</a>
      <a href="https://github.com/whtevn/one-track/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/whtevn/one-track/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installation</h2>

<pre><code>npm install one-track --save
</code></pre>

<p>if intending to use with koa2</p>

<pre><code>npm install one-track one-track-koa koa@next koa-bodyparse@3 --save
</code></pre>

<p>note that none of those are required to use this package, but they are 
used in the demonstrations below</p>

<h2>
<a id="usage-with-koa2" class="anchor" href="#usage-with-koa2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Usage with Koa2</h2>

<pre><code>import Koa from 'koa';
import bodyParser from 'koa-bodyparser';
import RouteManager from 'one-track';
import RouteMiddleware from 'one-track-koa';

import { retrieve_user } from './your-app';

const app          = new Koa();
const Router       = new RouteManager();

Router.GET('/user/:id', retrieve_user);

app.use(bodyParser());
app.use(RouteMiddleware(Router))
</code></pre>

<p>The above code will create the routes described, and call the functions
implied with the following argument signature </p>

<pre><code>(headers, params, body, app)
</code></pre>

<p>where <code>app</code> is the Koa app context. Router supports standard CRUD opperations</p>

<p>for example:</p>

<pre><code>Router.GET('/user/:id', retrieve_user);
Router.POST('/user', create_user);
Router.PUT('/user/:id', update_user);
Router.DELETE('/user/:id', delete_user);
</code></pre>

<h2>
<a id="router-chaining-" class="anchor" href="#router-chaining-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Router Chaining </h2>

<p>Routers can be created from other Routers without disturbing the original</p>

<pre><code>const Router       = new RouteManager();
Router.GET('/user/:id', retrieve_user);

Router_2 = new RouteManager(Router);
Router_2.Post('/user');
</code></pre>

<p>In the above example, the Router object has 1 route (<code>GET '/user/:id'</code>), and the
<code>Router_2</code> object has 2 (<code>GET '/user/:id'</code> and <code>POST '/user'</code>);</p>

<h2>
<a id="routed-function-context-" class="anchor" href="#routed-function-context-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Routed Function Context </h2>

<p>Sometimes it is important to dictate the scope that a function is called, defining
<code>this</code> for the context of the function. To do this, an array notation of <code>[scope, function]</code> 
is used. </p>

<p>If the function is a string, the context is searched for the function's name</p>

<pre><code>Router.get('/user/:id', [user, 'find']); //=&gt; user['find'].call(user, ...args)
</code></pre>

<p>Otherwise the function is called with the context given</p>

<pre><code>Router.get('/user/:id', [user, retrieve_user]); //=&gt; retrieve_user.call(user, ...args)
</code></pre>

<h2>
<a id="argument-translation-" class="anchor" href="#argument-translation-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Argument Translation </h2>

<p>Argument translators can be used to map the unweildy data from the request
into something an environment-agnostic method can process</p>

<pre><code>import Koa from 'koa';
import bodyParser from 'koa-bodyparser';
import RouteManager, { Send } from 'one-track';
import RouteMiddleware from 'one-track-koa';

import { retrieve_user } from './your-app';

// translate the arguments that come from the koa app
// into something that the retrieve_user method can understand

const koa_retrieve_user = Send((headers, params, body, app) =&gt; [params.id]).to(retrieve_user);

Router.GET('/user/:id', koa_retrieve_user);
</code></pre>

<p>This allows you to create functions that do not care about the environment that they 
ultimately live in. This also allows functions to live in multiple contexts, and for
contexts to change, without affecting the business logic</p>

<p>Argument translations also respond to the array notation given above</p>

<pre><code>Send((headers, params, body, app) =&gt; [params.id]).to([User, retrieve_user]);
</code></pre>

<h2>
<a id="general-usage-" class="anchor" href="#general-usage-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>General Usage </h2>

<p>One-Track does not require a server to work. Any application which can
receive events can be routed through this software.</p>

<pre><code>import RouteManager, { Send, GET } from 'one-track';
const Router = new RouteManager();

Router.GET('/path/:id/other/:info', another_function);
</code></pre>

<p>In this case, calling</p>

<pre><code>Router.find(GET, '/path/some_id/other/text_to_send')
</code></pre>

<p>is basically equivalent to calling</p>

<pre><code>(function(){
  return new Promise(resolve, reject){
    resolve(another_function.call(this, ...arguments));
  }
})()
</code></pre>

<h1>
<a id="hello-world-with-koa2-" class="anchor" href="#hello-world-with-koa2-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hello World with Koa2 </h1>

<pre><code>import Koa from 'koa';
import bodyParser from 'koa-bodyparser';
import RouteManager from '../index';
import RouteMiddleware from '../one-track-koa';

const app          = new Koa();
const Router       = new RouteManager();

function hello({place}){
  console.log("in hello");
  return "hello, "+place
}

function goodbye(){
  console.log("in goodbye");
  return "goodbye"
}

function say(phrase){
  console.log("in say");
  return "say "+phrase;
}

Router.GET('/hello/:place', hello);            // =&gt; hello, {place}
Router.GET('/say/hello/:place', hello, say);   // =&gt; say hello, {place}      
Router.GET('/say/goodbye', goodbye, say);      // =&gt; say goodbye
Router.GET('/goodbye', goodbye);               // =&gt; goodbye

app.use(bodyParser());
app.use(RouteMiddleware(Router))

app.listen(3000);
console.log("app is listening");
</code></pre>

<h1>
<a id="more-examples-" class="anchor" href="#more-examples-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>More Examples </h1>

<p>== Authentication Middleware: 2 ways</p>

<p>The first method uses argument translations </p>

<pre><code>  // this is a simple signature method that should not be used in production 
  const sign  = (user, secret=SECRET) =&gt; user+secret;

  // step 1: translate args to a method your validation function will understand.
  //         in this case we are returning the user id and auth sent in the header
  //         followed by the rest of the arguments in the appropriate order
  function authentication_arguments(headers, ...args){
    return [headers.user_id, headers.authorization, headers, ...args]
  }

  // step 2: validate the user and return the remaining arguments
  function validate_authentication(user, token, ...args){
     if(sign(user, SECRET) !== token) throw {code:401, message:"Unauthorized"}
     return args
  }

  // step 3: create the authentication middleware by sending the proper authentication
  //         arguments to the authentication checker
  const authenticate = Send(authentication_arguments).to(validate_authentication);
</code></pre>

<p>The second just does the job</p>

<pre><code>/***************************************/
  // NOTE: very little of the above is actually required. The following function `simple_auth`
  //       and the constant `authenticate` created above are functionally equivalent.
  //       the advantage of the `authenticate` constant being that the algorithm is not 
  //       tied to the request-related arguments as they are sent
  function simple_auth(headers, ...args){
    if(sign(headers.user_id, SECRET) !== headers.authorization) throw {code:401, message:"Unauthorized"}
    return [headers, ...args]
  }
/***************************************/
</code></pre>

<p>example usage of above middleware</p>

<pre><code>// example request headers:
//   user_id      : APPLE
//   Authorization: APPLESAUCE
R2.POST('/goodbye/:say', authenticate,
                        Send((headers, params)=&gt;[params.say]).to(goodbye),
                        say);       
</code></pre>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/whtevn/one-track">One-track</a> is maintained by <a href="https://github.com/whtevn">whtevn</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
